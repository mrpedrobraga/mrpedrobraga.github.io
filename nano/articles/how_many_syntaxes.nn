# Direct condition check

if <condition> then <consequence>
elif <condition> then <consequence>
unless <condition> then <consequence>
elun <condition> then <consequence>
else <consequence>

# Loops

loop <expression>
while <condition> do <expression>

# Container comprehensions

for <id> in <iterable> do <expression> [when <condition>]
for <id> in <iterable> some <condition> [when <condition>]
for <id> in <iterable> every <condition> [when <condition>]ok
for <id> in <iterable> select <expression> [when <condition>]
# for <id> in <iterable> count <expression> [when <condition>]
for <a>, <b> across <iterable> select <expression> [when <condition>]

# Synchronization Handling

await <awaitable> meanwhile <expression>

# Callables

fn <parameter_list> -> <expression>
fn <name> (<parameter_list>): <return_type> [implies <constraint>] -> <expression>
err_handler (<parameter_list>) -> <expression>

# Handlers

with PanicErrorHandler
with Task<int>

# Pattern matching

# match (when <condition> then <expression>)+
# match <what> (when <condition> then <expression> | with <condition> then <expression>)+
match <what> with <pattern_matcher>

# Importing

from <module> import <symbols>
export <symbols>
