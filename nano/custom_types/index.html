<!DOCTYPE html>
<html lang="en" class="inverted" style="--dark:#1a1e27;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mrpedrobraga ~/nano</title>

    <link rel="stylesheet" type="text/css" href="../../lib/atom-one-dark.min.css">
    <script src="../../lib/highlight.min.js"></script>
    <script src="../highlight_nano.js"></script>
    <script>hljs.highlightAll();</script>

    <link rel="stylesheet" type="text/css" href="../../main.css">
</head>
<body>
    <header class="small">
        <h1>nano</h1>
    </header>
    <div class="flex h gap page_container">
        <aside>
            <h2>nano</h2>
            <ul>
                <li><a href="../">What is nano?</a></li>
                <li><a href="../design_goals">Design Goals</a></li>
                <br>
                <h3>Learn!</h3>
                <li><a href=".">Data Types</a></li>
                <li><a href="../variables">Variables</a></li>
                <li><a href="../functions">Functions</a></li>
            </ul>
        </aside>
        <main>
            <div class="content centred">
                <p>
                    <pre><code># It is possible to create your own data types by combining
                        # existing types.
                        # We'll see all about that on the [[Structures]] section.
                        type SIPair = [string, int]

                        let si0: SIPair = ["Ooo", 3]

                        # What you just saw was an implicit conversion
                        # (literals will be converted on initialization)

                        type MyInt = int
                        let mi0: MyInt = 6

                        # But this isn't allowed.
                        let num2: int = 7
                        mi0 = num2  # `int` isn't assignable to `m10`.

                        # You will need to explicitly convert the value with `as`
                        mi10 = num2 as MyInt

                        # This allows you to signal to the consumer of your code
                        # that despite sharing the same data format, MyInt has
                        # a different meaning and usage than int.

                        # If you do want to allow the implicit conversion either way,
                        # you can declare an alias.
                        alias MyInt2 = int

                        # nano will understand MyInt2 is just "another way of saying int"
                        # and not a "new type."

                        # There are many fun ways of creating types:
                        type Zero = 0

                        # This type only accepts 0.
                        # You can only assign 0 to it, but IT can be assigned to any integer.
                        mi0 = (0 as Zero)

                        # Type disjunctions
                        type Bit = 1 | 0

                        # A 'Bit' here is either the integer 1 or the integer 0.
                        # For safety, it isn't assignable to Zero, for example.
                        # You have to 'narrow' the type before trying to assign
                        # to a more restrictive type.
                        # We'll learn about 'type narrowing' on [[Control Flow]].
                        # But since all sides are ints, it is assignable to int.
                        mi0 = (0 as Bit)

                        # Type conjunction
                        type Strint = string & int

                        # A 'Strint' here is "both" a string AND an int.
                        # There's no way of creating such value, it is only
                        # useful with [[Structures]].

                        # But the takeaway is that Strint is assignable to
                        # both string and int.

                        # Enumerators are a way of quickly declaring lots of 
                        # constants, holding values.

                        enum {
                        &nbsp;&nbsp;HELLO
                        &nbsp;&nbsp;THERE
                        &nbsp;&nbsp;BUDDY
                        }

                        # Here, HELLO = 0, THERE = 1, and so on.
                        # The 'flags' syntax makes its variants take powers of two.

                        flags {
                        &nbsp;&nbsp;A
                        &nbsp;&nbsp;B
                        &nbsp;&nbsp;C
                        }

                        # And giving it an extension type (string)
                        # makes its variants take strings as values.
                        enum : string {
                        &nbsp;&nbsp;NEVER
                        &nbsp;&nbsp;GONNA
                        &nbsp;&nbsp;GIVE
                        }

                        # Here's the kicker, enumerations can also be types!
                        enum Handedness {
                        &nbsp;&nbsp;LEFT_HANDED
                        &nbsp;&nbsp;RIGHT_HANDED
                        }

                        let my_handedness = Handedness.LEFT_HANDED

                        # An enum type will hint nano where to look for symbols
                        # it can't find on scope. So this works:
                        my_handedness = RIGHT_HANDED
                        # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^ because my_handedness is an enum type,
                        # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it'll look within that type for 'RIGHT_HANDED'

                        # Types can be as simple or as complex as you need.
                        # They are the building block of meaning on your codebase,
                        # and will keep your code clean, understandable and safe.
                    </code></pre>
                </p>
            </div>
        </main>
        <aside></aside>
    </div>
    <footer>
        <h3>Powered by evil and spite!</h3>
    </footer>
</body>
</html>