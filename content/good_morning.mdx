import Important from "../../components/Important.astro";
import Malign from "../../components/Malign.astro";
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Card } from '@astrojs/starlight/components';

## What is Sol?

<Important>Sol</Important> is a **beautiful** language for creating custom data with text. It is designed primarily for video games, but can be used for anything, really.

Sol is easy to learn and use even for non-programmers. We know that building projects is an iterative process, so Sol is designed to be easy to read and refactor.
Say goodbye to <Malign>JSON, XML, CSV</Malign>.

It is [open-source](https://github.com/mrpedrobraga/tree-sitter-sol/blob/main/LICENSE) and engine-agnostic, so it's entirely portable, allowing you to truly own your game content.

<Tabs>
  <TabItem label="1">
```sol
scene "Main"
  [Bob smiling]
  - Hello, World!
end
```
  </TabItem>
  <TabItem label="2">
```sol
model Item
  field name : text
  field consume_when_used : yes
  field durability : nat if consume_when_used
  field on_use : Action
end
```
  </TabItem>
  <TabItem label="3">
```sol collapse={8-10}
impl Item

name = "Hamburger"
consume_when_used = yes
durability = 1

action on_use(target: Character)
  * Yum! Tastes like cardboard!
  target.stats.heal(10HP)
  * {target.name} healed 10 HP.
end
```
  </TabItem>
</Tabs>


<Aside type="caution" title="Hold your horses!">
  Sol is still in early development and can not be used yet. Feel free to explore the docs, though!
</Aside>

<br/>

## Features

Sol's biggest feature is its structured way of defining things. It _knows_ the elements of your project and can provide assistance when you're creating new assets.

### The format

Sol works under a workspace. After creating an `index.sol` at your directory root, all files under it are inside your project.

```sol title="game/rooms/school.sol"
using game.rooms.beach;
# Files must be explicitly "using" each other,
# helping Sol and you understand their relationships.

scene "Beach Invite"
  [Carl]
  - Let's go to the beach.

  change_room(to: beach)
end
```

Because it's just text files, Sol can be checked into version control with [git](https://git-scm.com/).
```sol del={3} ins={4}
scene "Agatha Dies"
  [Agatha]
  - Oops guess I'll die *dies*
  - You... I thought I could trust you...
end
```

If you don't want to write text, though, Sol can be used as a _protocol_ for a graphical editor.

### Models

You can create your own (typed) models. When building an asset, it will `impl`ement a model like this:

```sol
model Item
  ## The name of the item as it will appear in dialogues and inventories.
  field name : text

  ## Whether the item disappears when used.
  field consumed_when_used : truth

  ## How many times can the item be used before breaking
  field durability : nat if consume_when_used

  ## What happens when the item is used
  field on_use : Action(target: Character)
end
```

When you implement a model, Sol will <Malign>error</Malign>, at build time, if anything is incorrect. This means no surprises while the game is running.

Its language server will also provide inlay hints, hover information, jump to definition, etc.

<Tabs>
  <TabItem label="JSON" icon="seti:json">
  ```json
  {
    "name": "Hamburger",
    "consumed_when_used": true,
    "durability": 1,
    "on_use": "good luck implementing your own JSON DSL"

    // This comment is highlighted but is actually
    // not valid JSON lmao.
  }
  ```
  </TabItem>
  <TabItem label="XML" icon="seti:xml">
  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <root>
    <name>Hamburger</name>
    <consumed_when_used>1</consumed_when_used>
    <durability>1</durability>
    <on_use>if you implement a DSL on XML actually I fear for your sanity</on_use>
  </root>
  ```
  </TabItem>
  <TabItem label="TOML" icon="seti:toml">
  ```toml
  # Looks pretty good actually

  name = "Hamburger"
  consumed_when_used = true
  durability = 1
  on_use = "hi mazur"
  ```
  </TabItem>
  <TabItem label="Sol" icon="sun">
  ```sol
  impl game.Item

  name = "Hamburger"
  consumed_when_used = yes
  durability = 1

  action on_use (target: Character)
    * {target.name} eats the {name}.
    #todo Discuss how much it should heal
    target.stats.heal(HP, 10)
    * 10 HP restored.
  end
  ```
  </TabItem>
</Tabs>

<br/>
### Dialogues

Sol has syntax for dialogues, allowing you to write cutscenes that look like screenplays.

```sol {3, 6}
scene "Main"
  [Pedro serious]
  - Good Morning.

  [You confused]
  - Oh, hey, Good Morning!
  # You say that because you're very polite.
end
```

Write sophisticated game logic by creating models (e.g. `Item`, `Interactible`) and then using them.

```sol
## Chests are {Interactible}s that contain an amount of some item inside.
## Opening a chest makes it empty.
scene "Open Chest" (quantity: nat, item: Item, chest: Interactible)
  #todo Add support for empty and trapped chests.

  * You opened the chest.
  * It had {quantity}x {item.name} inside!
  let successful = player.inventory.try_give(item, quantity)
  if successful then
    chest.exhausted = yes
  end
end
```

Add arbitrary BBCode-like markers to your text.
```sol
- Hello, [wave]there[/wave].
# Sol only offers *parsing* of these, of course.
# The effect of the marker needs to be implemented by you on your dialog box.
```

<br/>
### Facts

If your game has story or progression you can represent them in Sol using facts.

To guarantee stability in the game and avoid bugs, Sol follows the motto "make invalid states unrepresentable." Its model for keeping track of flags (algebraic facts) is the best example of it.

`either` means one of the flags inside must be set. `group` has a collection of flags or normal values.

```sol
let CHAPTER_1 : either {
  ## Intro animations and whatever
  SCHOOL_BEGGINING,

  DUNGEON_1 : either {
    PART_1,
    PART_2,
    PART_3 : group {
      BOSS_STATUS: either {
        BEFORE_BOSS,
        AFTER_BOSS : group {
          death_count : i32,
          used_violence : truth,
        }
      },
      SECRET_PUZZLE_STATUS: either {
        UNDISCOVERED,
        UNFINISHED,
        COMPLETED_N_TIMES : i32
      },
    },
  },

  ## Main thing is that the player is angry at Alex lmao
  RETURNED_TO_SCHOOL,
}
```

Sol has a concept of `save files` which helps you serialize state into and out of files.

<br/>
## Todos

Sol has `#todo`s, which mark some part of an asset or scene as unfinished.

<Aside type="tip">
  A recommended way of building assets and scenes is by creating the `.sol` files as you have ideas (put them in the right directories OR in a directory named "to-be-sorted"), but not actually implementing them.
  <br/>

  ```sol
  scene "Cool Idea"
    #todo I thought it would be cool if idk Marc got hit by his own flame and burned? Kinda in a karmic/poetic way???
  end
  ```
  <br/>

  Then, you can come back later and clean it up.
</Aside>

Todos will generate warnings during build, so you'll never forget what is left to be done ;-)

<br/>
## Roadmap

#### Are we 1.0 yet? (Not even close)
- [x] Design
- [ ] Parser
- [ ] Language Server
- [ ] Interpreter
- [ ] Bindings
  - [ ] Plain Rust
  - [ ] Bevy
  - [ ] Godot Engine
<br/><br/>
## Contributing

Not yet available.
